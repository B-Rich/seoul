--- libvirt-0.9.2/configure.ac	2011-06-06 05:09:25.000000000 +0200
+++ libvirt-0.9.2-own/configure.ac	2011-06-23 17:13:31.000000000 +0200
@@ -281,6 +281,8 @@
   AC_HELP_STRING([--with-remote], [add remote driver support @<:@default=yes@:>@]),[],[with_remote=yes])
 AC_ARG_WITH([libvirtd],
   AC_HELP_STRING([--with-libvirtd], [add libvirtd support @<:@default=yes@:>@]),[],[with_libvirtd=yes])
+AC_ARG_WITH([nova],
+  AC_HELP_STRING([--with-nova], [add Nova support @<:@default=check@:>@]),[],[with_nova=yes])
 
 dnl
 dnl in case someone want to build static binaries
@@ -463,6 +465,11 @@
 fi
 AM_CONDITIONAL([WITH_TEST], [test "$with_test" = "yes"])
 
+if test "$with_nova" = "yes" ; then
+    AC_DEFINE_UNQUOTED([WITH_NOVA], 1, [whether NOVA driver is enabled])
+fi
+AM_CONDITIONAL([WITH_NOVA], [test "$with_nova" = "yes"])
+
 if test "$with_remote" = "yes" ; then
     AC_DEFINE_UNQUOTED([WITH_REMOTE], 1, [whether Remote driver is enabled])
 fi
@@ -2431,6 +2438,7 @@
 AC_MSG_NOTICE([     LXC: $with_lxc])
 AC_MSG_NOTICE([    PHYP: $with_phyp])
 AC_MSG_NOTICE([     ESX: $with_esx])
+AC_MSG_NOTICE([    NOVA: $with_nova])
 AC_MSG_NOTICE([    Test: $with_test])
 AC_MSG_NOTICE([  Remote: $with_remote])
 AC_MSG_NOTICE([ Network: $with_network])
--- libvirt-0.9.2/src/Makefile.am	2011-06-06 02:15:12.000000000 +0200
+++ libvirt-0.9.2-own/src/Makefile.am	2011-06-23 17:13:31.000000000 +0200
@@ -284,6 +284,9 @@
 		lxc/lxc_controller.c				\
 		lxc/veth.c lxc/veth.h
 
+NOVA_DRIVER_SOURCES =						\
+		nova/nova_driver.c nova/nova_driver.h
+
 SECURITY_DRIVER_APPARMOR_HELPER_SOURCES =			\
 		security/virt-aa-helper.c
 
@@ -545,6 +548,21 @@
 libvirt_driver_test_la_SOURCES = $(TEST_DRIVER_SOURCES)
 endif
 
+if WITH_NOVA
+if WITH_DRIVER_MODULES
+mod_LTLIBRARIES += libvirt_driver_nova.la
+else
+noinst_LTLIBRARIES += libvirt_driver_nova.la
+libvirt_la_BUILT_LIBADD += libvirt_driver_nova.la
+endif
+libvirt_driver_nova_la_CFLAGS = \
+		-I@top_srcdir@/src/conf $(AM_CFLAGS)
+if WITH_DRIVER_MODULES
+libvirt_driver_nova_la_LDFLAGS = -module -avoid-version $(AM_LDFLAGS)
+endif
+libvirt_driver_nova_la_SOURCES = $(NOVA_DRIVER_SOURCES)
+endif
+
 if WITH_REMOTE
 if WITH_DRIVER_MODULES
 mod_LTLIBRARIES += libvirt_driver_remote.la
@@ -1001,6 +1019,7 @@
 		$(LIBXL_DRIVER_SOURCES)			\
 		$(ESX_DRIVER_SOURCES)				\
 		$(ESX_DRIVER_EXTRA_DIST)			\
+		$(NOVA_DRIVER_SOURCES)				\
 		$(NETWORK_DRIVER_SOURCES)			\
 		$(INTERFACE_DRIVER_SOURCES)			\
 		$(STORAGE_DRIVER_SOURCES)			\
@@ -1287,6 +1306,10 @@
 	$(MKDIR_P) "$(DESTDIR)$(localstatedir)/run/libvirt/libxl"
 	$(MKDIR_P) "$(DESTDIR)$(localstatedir)/log/libvirt/libxl"
 endif
+if WITH_NOVA
+	$(MKDIR_P) "$(DESTDIR)$(localstatedir)/lib/libvirt/nova"
+	$(MKDIR_P) "$(DESTDIR)$(localstatedir)/run/libvirt/nova"
+endif
 if WITH_UML
 	$(MKDIR_P) "$(DESTDIR)$(localstatedir)/lib/libvirt/uml"
 	$(MKDIR_P) "$(DESTDIR)$(localstatedir)/run/libvirt/uml"
@@ -1329,6 +1352,10 @@
 	rmdir "$(DESTDIR)$(localstatedir)/run/libvirt/libxl" ||:
 	rmdir "$(DESTDIR)$(localstatedir)/log/libvirt/libxl" ||:
 endif
+if WITH_NOVA
+	rmdir "$(DESTDIR)$(localstatedir)/lib/libvirt/nova" ||:
+	rmdir "$(DESTDIR)$(localstatedir)/run/libvirt/nova" ||:
+endif
 if WITH_UML
 	rmdir "$(DESTDIR)$(localstatedir)/lib/libvirt/uml" ||:
 	rmdir "$(DESTDIR)$(localstatedir)/run/libvirt/uml" ||:
--- libvirt-0.9.2/src/driver.h	2011-05-29 12:58:54.000000000 +0200
+++ libvirt-0.9.2-own/src/driver.h	2011-06-23 17:13:31.000000000 +0200
@@ -29,6 +29,7 @@
     VIR_DRV_XENAPI = 12,
     VIR_DRV_VMWARE = 13,
     VIR_DRV_LIBXL = 14,
+    VIR_DRV_NOVA
 } virDrvNo;
 
 
--- libvirt-0.9.2/src/libvirt.c	2011-06-06 02:15:12.000000000 +0200
+++ libvirt-0.9.2-own/src/libvirt.c	2011-06-23 17:13:31.000000000 +0200
@@ -68,6 +68,9 @@
 # ifdef WITH_XENAPI
 #  include "xenapi/xenapi_driver.h"
 # endif
+# ifdef WITH_NOVA
+#  include "nova/nova_driver.h"
+# endif
 #endif
 
 #define VIR_FROM_THIS VIR_FROM_NONE
@@ -432,6 +435,9 @@
 # ifdef WITH_XENAPI
     virDriverLoadModule("xenapi");
 # endif
+# ifdef WITH_NOVA
+    virDriverLoadModule("nova");
+#endif
 # ifdef WITH_REMOTE
     virDriverLoadModule("remote");
 # endif
@@ -460,6 +466,9 @@
 # ifdef WITH_XENAPI
     if (xenapiRegister() == -1) return -1;
 # endif
+# ifdef WITH_NOVA
+    if (novaRegister () == -1) return -1;
+# endif
 # ifdef WITH_REMOTE
     if (remoteRegister () == -1) return -1;
 # endif
@@ -979,6 +988,10 @@
         if (STRCASEEQ(type, "ESX"))
             *typeVer = LIBVIR_VERSION_NUMBER;
 # endif
+# if WITH_NOVA
+        if (STRCASEEQ(type, "NOVA"))
+            *typeVer = LIBVIR_VERSION_NUMBER;
+# endif
 # if WITH_XENAPI
         if (STRCASEEQ(type, "XenAPI"))
             *typeVer = LIBVIR_VERSION_NUMBER;
--- libvirt-0.9.2/src/conf/domain_event.c	2011-06-06 02:15:12.000000000 +0200
+++ libvirt-0.9.2-own/src/conf/domain_event.c	2011-06-29 14:01:15.000000000 +0200
@@ -362,6 +362,7 @@
     for (i = 0 ; i < cbList->count ; i++) {
         if (cbList->callbacks[i]->cb == VIR_DOMAIN_EVENT_CALLBACK(callback) &&
             cbList->callbacks[i]->eventID == VIR_DOMAIN_EVENT_ID_LIFECYCLE &&
+            (!cbList->callbacks[i]->dom || !dom || memcmp(dom->uuid, cbList->callbacks[i]->dom->uuid, VIR_UUID_BUFLEN) == 0) &&
             cbList->callbacks[i]->conn == conn) {
             eventReportError(VIR_ERR_INTERNAL_ERROR, "%s",
                              _("event callback already tracked"));
--- libvirt-0.9.2/examples/domain-events/events-c/event-test.c	2011-05-29 14:52:16.000000000 +0200
+++ libvirt-0.9.2-own/examples/domain-events/events-c/event-test.c	2011-06-23 17:13:31.000000000 +0200
@@ -145,9 +145,9 @@
                                   int detail,
                                   void *opaque ATTRIBUTE_UNUSED)
 {
-    printf("%s EVENT: Domain %s(%d) %s %s\n", __func__, virDomainGetName(dom),
+    printf("%s EVENT: Domain %s(%d) %s %s detail=%x\n", __func__, virDomainGetName(dom),
            virDomainGetID(dom), eventToString(event),
-           eventDetailToString(event, detail));
+           eventDetailToString(event, detail), detail);
     return 0;
 }
 
@@ -354,7 +354,7 @@
                                                     VIR_DOMAIN_EVENT_CALLBACK(myDomainEventControlErrorCallback),
                                                     strdup("callback control error"), myFreeFunc);
 
-    if ((callback1ret != -1) &&
+    if (//(callback1ret != -1) &&
         (callback2ret != -1) &&
         (callback3ret != -1) &&
         (callback4ret != -1) &&
diff -urN libvirt-0.9.2/src/nova/nova_conf.h libvirt-0.9.2-own/src/nova/nova_conf.h
--- libvirt-0.9.2/src/nova/nova_conf.h	1970-01-01 01:00:00.000000000 +0100
+++ libvirt-0.9.2-own/src/nova/nova_conf.h	2011-07-05 01:45:33.000000000 +0200
@@ -0,0 +1,16 @@
+#ifndef __VIR_NOVA_CONF_H__
+# define __VIR_NOVA_CONF_H__
+
+# include "domain_event.h"
+
+struct nova_conn {
+  int sockfd;
+  int eventfd;
+  virDomainEventCallbackListPtr domainEventCallbacks;
+//  virDomainEventQueuePtr domainEventQueue;
+  virThreadPtr eventthread;
+  bool lock_init;
+  virMutex lock;
+};
+
+#endif /* __VIR_NOVA_CONF_H__ */
diff -urN libvirt-0.9.2/src/nova/nova_driver.c libvirt-0.9.2-own/src/nova/nova_driver.c
--- libvirt-0.9.2/src/nova/nova_driver.c	1970-01-01 01:00:00.000000000 +0100
+++ libvirt-0.9.2-own/src/nova/nova_driver.c	2011-07-05 01:47:49.000000000 +0200
@@ -0,0 +1,463 @@
+#include <sys/socket.h> //socket
+#include <arpa/inet.h> //inet_pton
+
+#include "virterror_internal.h"
+#include "datatypes.h"
+#include "nova_driver.h"
+#include "buf.h"
+#include "util.h"
+#include "uuid.h"
+#include "capabilities.h"
+#include "memory.h"
+#include "network_conf.h"
+#include "interface_conf.h"
+#include "domain_conf.h"
+#include "domain_event.h"
+#include "event.h"
+#include "storage_conf.h"
+#include "node_device_conf.h"
+#include "xml.h"
+#include "threads.h"
+#include "logging.h"
+
+#include "nova_types.h"
+#include "nova_conf.h"
+
+#include <fcntl.h>
+
+static void novaReadEvents(void *data) {
+  virConnectPtr nconn = (virConnectPtr)data;
+  struct nova_conn * conn = (struct nova_conn *)nconn->privateData;
+
+  unsigned char buf[NOVA_PACKET_LEN];
+  int res;
+
+  while(true) {
+    unsigned count = 0;
+    while(count < sizeof(buf)) {
+      res = read(conn->eventfd, buf + count, sizeof(buf) - count);
+      if (res == -1) return;
+      count += res;
+    }
+
+    struct outgoing_packet * in = (struct outgoing_packet *)buf;
+
+    if (in->version != ntohs(0xafff)) { printf("eventthread - version error %x != %x\n", ntohs(in->version), 0xafff); continue;}
+    if (in->opcode != ntohs(NOVA_EVENT)) { printf("eventthread - opcode error %x != %x\n", ntohs(in->opcode), NOVA_EVENT ); continue;}
+
+    uint32_t eventid      = *((uint32_t *)(&in->opspecific + 16));
+    uint32_t extra_len    = *((uint32_t *)(&in->opspecific + 16 + sizeof(uint32_t)));
+    unsigned char * extra = &in->opspecific + 16 + 2 * sizeof(uint32_t);
+    virDomainEventPtr event;
+
+    virDomainPtr dom = virDomainLookupByUUID(nconn, &in->opspecific);
+    if (dom) {
+      if (ntohl(eventid) == EVENT_REBOOT)
+        event = virDomainEventRebootNewFromDom(dom);
+      else
+        event = virDomainEventNewFromDom(dom, ntohl(eventid), ntohl(extra_len) == sizeof(uint32_t) ? *((uint32_t *)extra) : 0);
+    } else {
+      event = virDomainEventNew(-2, "hw", &in->opspecific, ntohl(eventid),
+        ntohl(extra_len) == sizeof(uint32_t) ? *((uint32_t *)extra) : 0);
+      printf("got hw event %p %x\n", event, ntohl(eventid));
+    }
+
+    if (!event) goto cleanup;
+//    if (virDomainEventQueuePush(conn->domainEventQueue, event) < 0) { virDomainEventFree(event); continue; }
+//    virDomainEventQueueDispatch(conn->domainEventQueue, conn->domainEventCallbacks, virDomainEventDispatchDefaultFunc, NULL);
+    virDomainEventDispatch(event, conn->domainEventCallbacks, virDomainEventDispatchDefaultFunc, NULL);
+
+    virDomainEventFree(event);
+
+    cleanup:
+    if (dom) virUnrefDomain(dom);
+  } 
+
+  return; 
+}
+
+static virDrvOpenStatus novaOpen(virConnectPtr conn,
+                    virConnectAuthPtr auth ATTRIBUTE_UNUSED,
+                    int flags ATTRIBUTE_UNUSED)
+{
+    int sockfd = 0, eventfd = 0;
+    struct nova_conn *nconn = 0;
+
+    if (!conn->uri)
+        return VIR_DRV_OPEN_DECLINED;
+
+    if (!conn->uri->scheme || STRNEQ(conn->uri->scheme, "nova"))
+        return VIR_DRV_OPEN_DECLINED;
+
+    if (!conn->uri->server || !conn->uri->port || conn->privateData)
+        return VIR_DRV_OPEN_DECLINED;
+
+    struct sockaddr_in addr;
+    addr.sin_family = AF_INET;
+    addr.sin_port = htons(conn->uri->port);
+    if (1 != inet_pton(AF_INET, conn->uri->server, &addr.sin_addr))
+      return VIR_DRV_OPEN_DECLINED;
+
+    sockfd = socket(AF_INET, SOCK_STREAM, 0);
+    if (sockfd < 0) goto error;
+    if (connect(sockfd, (struct sockaddr *)&addr, sizeof(addr))) goto error;
+
+    addr.sin_family = AF_INET;
+    addr.sin_port = htons(conn->uri->port + 1);
+    if (1 != inet_pton(AF_INET, conn->uri->server, &addr.sin_addr))
+      return VIR_DRV_OPEN_DECLINED;
+
+    eventfd = socket(AF_INET, SOCK_STREAM, 0);
+    if (eventfd < 0) goto error;
+    if (connect(eventfd, (struct sockaddr *)&addr, sizeof(addr))) goto error;
+
+    if (VIR_ALLOC(nconn) < 0) goto error;
+    memset(nconn, 0, sizeof(*nconn));
+    if (VIR_ALLOC(nconn->domainEventCallbacks) < 0) goto error;
+//    if (!(nconn->domainEventQueue = virDomainEventQueueNew())) goto error;
+
+    nconn->sockfd  = sockfd;
+    nconn->eventfd = eventfd;
+    conn->privateData = nconn;
+
+    if (VIR_ALLOC(nconn->eventthread) < 0) goto error; 
+    if (virMutexInit(&nconn->lock) < 0) goto error;
+    else nconn->lock_init = true;
+    if (virThreadCreate(nconn->eventthread, false, novaReadEvents, conn)) goto error;
+
+    return VIR_DRV_OPEN_SUCCESS;
+
+    error:
+    if (nconn && nconn->domainEventCallbacks) VIR_FREE(nconn->domainEventCallbacks);
+    if (nconn && nconn->eventthread) VIR_FREE(nconn->eventthread);
+    if (nconn && nconn->lock_init) virMutexDestroy(&nconn->lock);
+    if (nconn) VIR_FREE(nconn);
+    if (sockfd) close(sockfd);
+    if (eventfd) close(eventfd);
+
+    return VIR_DRV_OPEN_DECLINED;
+}
+
+static int novaClose(virConnectPtr conn)
+{
+    int res;
+    struct nova_conn *nconn;
+
+    if (!(nconn = conn->privateData)) return -1;
+    
+    res = close(nconn->sockfd);
+    res = close(nconn->eventfd);
+
+    if (nconn->domainEventCallbacks) VIR_FREE(nconn->domainEventCallbacks);
+//    if (nconn->domainEventQueue) virDomainEventQueueFree(nconn->domainEventQueue);
+    if (nconn->eventthread) {
+      virThreadJoin(nconn->eventthread);
+      VIR_FREE(nconn->eventthread);
+    }
+    if (nconn->lock_init) virMutexDestroy(&nconn->lock);
+    memset(nconn, 0, sizeof(*nconn));
+    VIR_FREE(nconn);
+    conn->privateData = 0;
+
+    printf("nova - %s - close connection to ...\n", res ? "failure" : "success");
+    return res;
+}
+
+#define create_nova_request(CONN, NOVAOPCODE, ERRORCODE, CODE) \
+  struct nova_conn *nconn = (CONN)->privateData; \
+  int sockfd = nconn->sockfd; \
+\
+  unsigned char buf[NOVA_PACKET_LEN]; \
+  struct incoming_packet * _out = (struct incoming_packet *)buf; \
+  ssize_t _res___; \
+\
+  _out->version = htons(0xafff); \
+  _out->opcode  = htons(NOVAOPCODE); \
+\
+  CODE \
+\
+  virMutexLock(&nconn->lock); \
+  unsigned ___count___ = 0; \
+  if (sizeof(buf) != write(sockfd, buf, sizeof(buf))) { _res___ = -1; goto request_abort; } \
+  while(___count___ < sizeof(buf)) { \
+    _res___ = read(sockfd, buf + ___count___, sizeof(buf) - ___count___); \
+    if (_res___ == -1) goto request_abort; \
+    ___count___ += _res___; \
+  } \
+  request_abort: \
+  virMutexUnlock(&nconn->lock); \
+  if (_res___ == -1) return ERRORCODE; \
+\
+  struct outgoing_packet * _in = (struct outgoing_packet *)buf; \
+\
+  if (_in->version != ntohs(0xafff)) { printf("version error\n"); return ERRORCODE; } \
+  if (_in->opcode != ntohs(NOVAOPCODE)) { printf("opcode error\n"); return ERRORCODE; } \
+  if (_in->result != NOVA_OP_SUCCEEDED) { return ERRORCODE; }
+
+static int nodeGetInfo(virConnectPtr conn, virNodeInfoPtr info) {
+  create_nova_request(conn, NOVA_HW_INFO, -1, {});
+
+  uint32_t * data = (uint32_t *)&_in->opspecific;
+  info->memory = ntohl(*data++); info->cpus = ntohl(*data++);
+  info->mhz = ntohl(*data++); info->nodes = ntohl(*data++);
+  info->sockets = ntohl(*data++); info->cores = ntohl(*data++);
+  info->threads = ntohl(*data++);
+  memcpy(info->model, data, 13);
+  return 0;
+}
+
+static int numOfDomains(virConnectPtr conn) {
+
+  create_nova_request(conn, NOVA_NUM_OF_ACTIVE_DOMAINS, -1, {});
+
+  uint32_t * num = (uint32_t *)&_in->opspecific;
+  uint32_t res = ntohl(*num);
+  return res;
+}
+
+static int listDomains (virConnectPtr conn,
+                            int *ids,
+                            int maxids)
+{
+  create_nova_request(conn, NOVA_LIST_ACTIVE_DOMAINS, -1, {});
+
+  unsigned i;
+  uint32_t * _ids  = (uint32_t *)&_in->opspecific;
+  uint32_t _maxids = ntohl(*_ids);
+
+  _ids++;
+
+  uint32_t max = _maxids < maxids ? _maxids : maxids;
+
+  for (i=0; i < max; i++) {
+    *ids = ntohl(*_ids);
+    ids++;
+    _ids++; 
+  }
+
+  return max;
+}
+
+static int numOfDefinedDomains(virConnectPtr conn) {
+  create_nova_request(conn, NOVA_NUM_OF_DEFINED_DOMAINS, -1, {});
+
+  uint32_t * num = (uint32_t *)&_in->opspecific;
+  uint32_t res = ntohl(*num);
+
+  return res;
+}
+
+static virDomainPtr domainLookupByUUID(virConnectPtr conn,
+                                       const unsigned char *uuid)
+{
+  create_nova_request(conn, NOVA_GET_NAME_UUID, NULL, 
+    {
+      memcpy(&_out->opspecific, uuid, VIR_UUID_BUFLEN);
+    });
+
+  buf[NOVA_PACKET_LEN - 1] = 0; //zero terminate for sure
+
+  uint32_t * _op = (uint32_t *)&_in->opspecific;
+  int id = ntohl(*_op);
+  char const * name = (char const *)(&_in->opspecific + sizeof(*_op));
+
+  virDomainPtr res = virGetDomain(conn, name, uuid);
+  if (res) res->id = id;
+
+  return res;
+}
+
+static virDomainPtr domainLookupByID(virConnectPtr conn, int id)
+{
+  create_nova_request(conn, NOVA_GET_NAME_ID, NULL, 
+    {
+      uint32_t * out_id = (uint32_t *)&_out->opspecific;
+      *out_id = htonl(id);
+    });
+
+  buf[NOVA_PACKET_LEN - 1] = 0; //zero terminate for sure
+  unsigned char const * uuid = (unsigned char const *)&_in->opspecific;
+  char const * name = (char const *)(&_in->opspecific + 16);
+
+  virDomainPtr res = virGetDomain(conn, name, uuid);
+  if (res) res->id = id;
+
+  return res;
+}
+
+static int domainCreate(virDomainPtr domain) {
+  create_nova_request(domain->conn, NOVA_VM_START, -1, {
+    unsigned char _uuid[VIR_UUID_BUFLEN];
+    if (-1 == virUUIDGenerate(_uuid)) return -1;
+
+    char * uuid = (char *)&_out->opspecific;
+    memcpy(uuid, domain->uuid, VIR_UUID_BUFLEN);
+    uuid += VIR_UUID_BUFLEN;
+    memcpy(uuid, _uuid, VIR_UUID_BUFLEN);
+  });
+
+  uint32_t * _op = (uint32_t *)&_in->opspecific;
+  int id = ntohl(*_op);
+
+  if (id) {
+    virDomainPtr res = domainLookupByID(domain->conn, id);
+    if (res) res->id = id;
+    else return -1;
+  }
+  return 0;
+}
+
+static int domainIsPersistent(virDomainPtr dom) {
+  if (!dom) return -1;
+
+  if (dom->id == -1) return 1; //XXX fix it - guessing
+  return 0;
+}
+
+static int domainEventRegisterAny(virConnectPtr conn, 
+  virDomainPtr dom, int eventID, virConnectDomainEventGenericCallback cb,
+  void * opaque, virFreeCallback freecb) //XXX currently no registry per event possible, all or nothing for all domains or just for a specific
+{
+  int res;
+
+  create_nova_request(conn, NOVA_ENABLE_EVENT, -1, 
+    {
+      uint32_t * out_id = (uint32_t *)&_out->opspecific;
+      if (dom)
+        *out_id = htonl(dom->id);
+      else
+        *out_id = htonl(-1);
+    });
+
+  res = virDomainEventCallbackListAddID(conn,
+                                        nconn->domainEventCallbacks,
+                                        dom, eventID,
+                                        cb, opaque, freecb);
+  return res;
+}
+
+static int domainEventDeregisterAny(virConnectPtr conn, int callbackID)
+{
+  create_nova_request(conn, NOVA_DISABLE_EVENT, -1,
+    {
+      uint32_t * out_id = (uint32_t *)&_out->opspecific;
+      *out_id = htonl(-1);
+    });
+ 
+  return virDomainEventCallbackListRemoveID(conn, nconn->domainEventCallbacks, callbackID);
+}
+
+static int listDefinedDomains(virConnectPtr conn, char ** const names, int maxnames)
+{
+  unsigned i;
+  char * out;
+
+  create_nova_request(conn, NOVA_LIST_DEFINED_DOMAINS, -1, {
+      uint32_t * max = (uint32_t *)&_out->opspecific;
+      *max = htonl(maxnames);
+    });
+
+  uint32_t * _num = (uint32_t *)&_in->opspecific;
+  uint32_t    num = ntohl(*_num);
+  char     * name = (char *)(&_in->opspecific + 4);
+
+  for (i=0; i < num; i++) {
+    uint32_t len   = strlen(name) + 1;
+  
+    if (-1 == virAlloc(&out, len)) return -1;
+    memcpy(out, name, len);
+    names[i] = out;
+    name += len;
+  }
+
+  return num;
+}
+
+static virDomainPtr domainLookupByName(virConnectPtr conn, const char * name)
+{
+  create_nova_request(conn, NOVA_GET_NAME, NULL,
+    {
+      if (strlen(name) + 1 > NOVA_PACKET_LEN - (&_out->opspecific - buf)) return NULL;
+      memcpy(&_out->opspecific, name, strlen(name) + 1);
+    });
+
+  unsigned char const * uuid = (unsigned char const *)&_in->opspecific;
+  char const * _name = (char const *)(&_in->opspecific + 16);
+
+  if (memcmp(name, _name, strlen(name) + 1)) return NULL;
+  virDomainPtr res = virGetDomain(conn, name, uuid);
+  if (res) res->id = -1;
+
+  return res;
+}
+
+static int domainDestroy (virDomainPtr domain)
+{
+  if (!domain || domain->id == -1) return -1;
+
+  create_nova_request(domain->conn, NOVA_VM_DESTROY, -1, {
+      uint32_t * out_id = (uint32_t *)&_out->opspecific;
+      *out_id = htonl(domain->id);
+  });
+
+  return 0;
+}
+
+static int domainGetInfo (virDomainPtr domain,
+                          virDomainInfoPtr info)
+{
+  if (!info || !domain) return -1;
+
+  create_nova_request(domain->conn, NOVA_GET_VM_INFO, -1, {
+    memcpy(&_out->opspecific, domain->uuid, VIR_UUID_BUFLEN);
+  });
+
+  uint32_t * memory = (uint32_t *)&_in->opspecific;
+  uint32_t * vcpus  = (uint32_t *)(&_in->opspecific + sizeof(uint32_t));
+  uint64_t * t_cpu  = (uint64_t *)(&_in->opspecific + 2*sizeof(uint32_t));
+
+  if (domain->id == -1)
+    info->state  = VIR_DOMAIN_NOSTATE;
+  else
+    info->state  = VIR_DOMAIN_RUNNING;
+
+  info->maxMem    = ntohl(*memory);  // the maximum memory in KBytes allowed
+  info->memory    = ntohl(*memory);  // the memory in KBytes used by the domain
+  info->nrVirtCpu = ntohl(*vcpus);   // the number of virtual CPUs for the domain
+  info->cpuTime   = be64toh(*t_cpu) * 1000; // get in microseconds - time used in nanoseconds
+
+  return 0;
+}
+
+static virDriver novaDriver = {
+    .no = VIR_DRV_NOVA,
+    .name = "NOVA",
+    .open = novaOpen, /* 0.8.8 */
+    .close = novaClose, /* 0.8.8 */
+    .nodeGetInfo = nodeGetInfo, /* 0.2.0 */
+    .listDomains = listDomains, /* 0.8.8 */
+    .numOfDomains = numOfDomains, /* 0.8.8 */
+    .domainLookupByID = domainLookupByID, /* 0.8.8 */
+    .domainLookupByUUID = domainLookupByUUID, /* 0.8.8 */
+    .domainLookupByName = domainLookupByName, /* 0.8.8 */
+    .domainDestroy = domainDestroy, /* 0.8.8 */
+    .domainGetInfo = domainGetInfo, /* 0.8.8 */
+    .listDefinedDomains = listDefinedDomains, /* 0.8.8 */
+    .numOfDefinedDomains = numOfDefinedDomains, /* 0.8.8 */
+    .domainCreate = domainCreate, /* 0.8.8 */
+    .domainIsPersistent = domainIsPersistent, /* 0.8.8 */
+    .domainEventRegisterAny = domainEventRegisterAny, /* 0.8.8 */
+    .domainEventDeregisterAny = domainEventDeregisterAny, /* 0.8.8 */
+};
+
+/**
+ * NOVA Register:
+ *
+ * Registers the NOVA driver
+ */
+int
+novaRegister(void)
+{
+    if (virRegisterDriver(&novaDriver) < 0) return -1;
+    return 0;
+}
diff -urN libvirt-0.9.2/src/nova/nova_driver.h libvirt-0.9.2-own/src/nova/nova_driver.h
--- libvirt-0.9.2/src/nova/nova_driver.h	1970-01-01 01:00:00.000000000 +0100
+++ libvirt-0.9.2-own/src/nova/nova_driver.h	2011-06-23 17:13:31.000000000 +0200
@@ -0,0 +1,8 @@
+#ifndef __VIR_NOVA_INTERNAL_H__
+# define __VIR_NOVA_INTERNAL_H__
+
+# include "internal.h"
+
+int novaRegister(void);
+
+#endif /* __VIR_NOVA_INTERNAL_H__ */
diff -urN libvirt-0.9.2/src/nova/nova_types.h libvirt-0.9.2-own/src/nova/nova_types.h
--- libvirt-0.9.2/src/nova/nova_types.h	1970-01-01 01:00:00.000000000 +0100
+++ libvirt-0.9.2-own/src/nova/nova_types.h	2011-07-05 01:53:29.000000000 +0200
@@ -0,0 +1,37 @@
+enum LIBVIRT_NOVA_OPCODE {
+  NOVA_OP_FAILED   = 0x8,
+  NOVA_OP_SUCCEEDED = 0x9,
+  NOVA_PACKET_LEN  = 0x40,
+  NOVA_NUM_OF_ACTIVE_DOMAINS = 0x20,
+  NOVA_NUM_OF_DEFINED_DOMAINS,
+  NOVA_LIST_ACTIVE_DOMAINS,
+  NOVA_LIST_DEFINED_DOMAINS,
+  NOVA_GET_NAME_ID,
+  NOVA_GET_NAME_UUID,
+  NOVA_GET_NAME,
+  NOVA_GET_VM_INFO,
+  NOVA_VM_START,
+  NOVA_VM_DESTROY,
+  NOVA_UNSUPPORTED_VERSION,
+  NOVA_ENABLE_EVENT,
+  NOVA_DISABLE_EVENT,
+  NOVA_EVENT,
+  NOVA_HW_INFO,
+  EVENT_REBOOT = 0xbbbb,
+  EVENT_UNSERVED_IOACCESS = 0xbbc0,
+  EVENT_DMAR_ACCESS = 0xbbd0,
+  EVENT_VDEV_HONEYPOT = 0xbbd1,
+};
+
+struct incoming_packet {
+  uint16_t version;
+  uint16_t opcode;
+  unsigned char opspecific;
+} __attribute__((packed));
+
+struct outgoing_packet {
+  uint16_t version;
+  uint16_t opcode;
+  uint8_t  result;
+  unsigned char opspecific;
+} __attribute__((packed));

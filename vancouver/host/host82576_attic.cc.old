// -*- Mode: C++ -*-

// Just for reference

void ensure_rx_enabled()
{
  _hwreg[RCTL] |= RCTL_RXEN;
}


class RXQueue {
  static const unsigned desc_no = 16;
  Host82576 *_dev;
  unsigned _no;

  unsigned _last;

  // Advanced Receive Descriptors (7.1.5)
  struct RXDesc {
    union {
      uint64_t word0;
      uint64_t packet_buf;
    };
    union {
      uint64_t word1;
      uint64_t header_buf;
    };

    bool done() { return (word1 & 1) == 1; }
    uint8_t type() { return (word0 >> 4) & 0x1FFF; }
    uint16_t header_length() { return (word0 >> 21) & 0x1FF; }
    uint16_t packet_length() { return (word1 >> 32) & 0xFFFF; }
  };

  // Descriptors must be 128-byte aligned. (8.10.5)
  ALIGN(128) RXDesc desc[desc_no];
  struct {
    // Splitting is disabled.
    //ALIGN(2) char header[1024];
    ALIGN(2) char packet[2048];
  } desc_local[desc_no];	// For our personal use

  // Add offset _no*0x40/4
  enum RX40 {
    RDBAL  = 0x0C000/4,	// Base Address Low
    RDBAH  = 0x0C004/4,	// Base Address High
    RDLEN  = 0x0C008/4,	// Length
    RDH    = 0x0C010/4,	// Head
    RDT    = 0x0C018/4,	// Tail
    RXDCTL = 0x0C028/4,	// Receive Descriptor Control
    SRRCTL = 0x0C00C/4,	// Split and Replication Receive Control
    RQDPC  = 0x0C030/4,	// Drop Packet Count
  };

  // Add offset _no*8/4
  enum RX8 {
    RAL    = 0x05400/4,	// Receive Address Low
    RAH    = 0x05404/4,	// Receive Address High
  };

  enum RAH {
    RAH_AV = 1U<<31,		// Address Valid
  };

  enum Control {
    RXDCTL_ENABLE = 1<<25,	     // Queue Enable
    SRRCTL_DROP_ENABLE = 1U<<31,     // Drop Enable
    SRRCTL_DESCTYPE = 7<<25,	     // Descriptor Type
    SRRCTL_DESCTYPE_ADV_1BUF = 1<<25 // One Buffer, No Splitting
  };

  volatile uint32_t &_rxreg40(enum RX40 reg) { return _dev->_hwreg[0x10*_no + reg]; }
  volatile uint32_t &_rxreg8(enum RX8 reg)   { return _dev->_hwreg[   2*_no + reg]; }

public:

  void init_slot(unsigned i)
  {
    // Splitting is disabled.
    //desc[i].header_buf = _dev->to_phys(desc_local[i].header);
    desc[i].header_buf = 0;
    desc[i].packet_buf = _dev->to_phys(desc_local[i].packet);
  }

  void enable()
  {
    _dev->ensure_rx_enabled();
    _rxreg40(RXDCTL) = RXDCTL_ENABLE;

    for (unsigned i = 0; i < desc_no; i++) {
      init_slot(i);
    }

    _last = 0;
    // Just setting it to 0 does not work. So try it with a small
    // step first.
    _rxreg40(RDT) = 1;
    _rxreg40(RDT) = 0;	// All buffers valid.
  }

  unsigned dropped() { return _rxreg40(RQDPC); }

  void irq(uint32_t cause)
  {
    unsigned processed = 0;
      
    // Check that we don't loop forever when someone sends packets to
    // us like crazy by only running through the queue once.
    while ((processed++ < desc_no) && desc[_last].done()) {
      unsigned type = desc[_last].type();
      _dev->msg(Host82576::RX, "Packet received:%s%s%s%s%s (H:%u, P:%u)\n",
		(type & TYPE_L2) ? " L2" : "",
		(type & (TYPE_IPV4|TYPE_IPV4E)) ? " IPv4" : "",
		(type & (TYPE_IPV6|TYPE_IPV6E)) ? " IPv6" : "",
		(type & TYPE_TCP) ? " TCP" : "",
		(type & TYPE_UDP) ? " UDP" : "",
		desc[_last].header_length(),
		desc[_last].packet_length()
		);

      // Splitting is disabled, our header is in the packet buffer.
      //hexdump(desc_local[_last].packet, desc[_last].header_length());
      MessageNetwork msg((unsigned char *)desc_local[_last].packet, desc[_last].packet_length(), ~0U);
      if (!_dev->_bus_network.send(msg))
	_dev->msg(Host82576::RX, "Packet forward failed.\n");

      init_slot(_last);
      _last = (_last+1) % desc_no;

      asm volatile ("sfence" ::: "memory");
      _rxreg40(RDT) = _last;
    }

    unsigned dropped = _rxreg40(RQDPC);
    if (dropped > 0) _dev->msg(Host82576::RX, "Dropped %u packets.\n", dropped);
  }

  RXQueue(Host82576 *dev, unsigned no)
    : _dev(dev), _no(no)
  {
    memset(desc, 0, sizeof(desc)); // Just to be sure.

    uint64_t phys_desc = _dev->to_phys(desc);
    _rxreg40(RXDCTL) = 0;	// Disable queue.
    _rxreg40(SRRCTL) = (_rxreg40(SRRCTL) & ~SRRCTL_DESCTYPE) |
      SRRCTL_DESCTYPE_ADV_1BUF | SRRCTL_DROP_ENABLE;

    _rxreg40(RDBAL) = phys_desc & 0xFFFFFFFFU;
    _rxreg40(RDBAH) = phys_desc >> 32;
    _rxreg40(RDLEN) = sizeof(RXDesc)*desc_no;

    // Accept packets for our MAC.
    _rxreg8(RAL) = _dev->_mac.raw;
    _rxreg8(RAH) = _dev->_mac.raw >> 32 | RAH_AV;

    _dev->msg(Host82576::RX, "RX queue %u initialized with %u descriptors (%u bytes).\n", no,
	      desc_no, _rxreg40(RDLEN));

  }
} *_rx;
